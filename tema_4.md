# Тема 4. Функции и модули
Отчет по Теме #4 выполнил:
- Боровягин Данил Андреевич
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |
| Задание 6 | + |   |
| Задание 7 | + |   |
| Задание 8 | + |   |
| Задание 9 | + |   |
| Задание 10 | + |   |

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1

### Напишите функцию, которая выполняет любые арифметические действия и выводит результат в консоль. Вызовите функцию используя "точку входа".

```python
def main():
    print(2+2)

if __name__ == "__main__":
    main()

def good():
    print(2*5)

good()
```
### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/lab_4/1.jpg)

## Выводы

В данном коде я рассмотрел функцию `def` которая вызывается при помощи модуля `__name__` этот модуль определён изначально как `__main__` потому ессли заменить название модуля на любое другое программа не сработает правильно  условие if __name__ == "__main__": проверяет, является ли текущий модуль главным (то есть модуль запущен напрямую, а не импортирован другим модулем)

## Лабораторная работа №2

### Напишите функцию, которая выполняет любые арифметические действия, возвращает при помощи return значение в место, откуда вызывали функцию. Выведите результат в консоль. Вызовите функцию используя "точку входа".

## Первый вариант решиня

```python
def main():
    result = 44 * 4
    sum = result // 2
    result = sum
    return result

if __name__ == "__main__":
    answer = main()
    print(answer)

f= 5
d = 3

if f**d*5 > answer:
    print("xxx")
else:
    print("LOL")
```


### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/lab_4/2.jpg)

## Выводы

В данном коде я попытался посмотреть как работает модуль `main` как можно применить его. Так же понял как работает `return` он возвращает значение и прерывает выполнение модуля, если бы у нас было что то написано после `return` то модуль бы это уже не учитывал и при вызове `answer` мы получили бы значание сохранённое из `return`.

## Лабораторная работа №3

### Напишите функцию, в которую передаются два аргумента, над ними производится арифметическое действие, результат возвращается туда, откуда эту функцию вызывали. Выведите результат в консоль. Вызовите функцию в любом небольшом цикле.
На скриншоте ниже приведен пример программы, в которой аргумент функции "x"превращается в параметр "one", то же самое происходит с "y" и "two"


```python
def main(one, two, four, free):
    res = one + two
    sum1 = four * free
    return sum1


for _ in range(4):
    x = 4
    y = 44
    a = 444
    b = 2
    an = main(x, a, y, b)
    print(an)
an1 = main(4, 44, 444, 4444)
print(an1)
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/lab_4/3.jpg)

## Выводы

В данном коде представленна функция `main` в которой есть 4 переменные 2 из которых суммируются, а 2 другие складываются переменные можно задать как отдельно присвоив значения а потом добавить в функцию, так и сразуу ввести значения через запятую. 

## Лабораторная работа №4

### Напишите функцию, на вход которой подается какое-то изначальное неизвестное количество аргументов, над которыми будет производится арифметические действия. Для выполнения задания необходимо использовать кортеж "*args". На скриншоте ниже приведен пример такой программы с комментариями.
Для закрепления понимания работы с кортежами настоятельно рекомендуем поменять аргументы вызова функции, вручную посчитать результат, только потом запустить программу с новыми значениями и проверить себя, насколько вы поняли данный аспект
программирования.

```python
def main(x, y, z, *args):
    one = x
    xac = y
    xac1 = z
    ron = xac**2
    ron1 = xac1*2
    two = sum(args)
    three = float(len(args))
    test = args[7] + args[6] / args[0]

    print(f"one={one}\ntwo={two}\nthree={three}\nfour={ron}\nfive={ron1}")

    return (x + sum(args) / float(len(args)) - y ** z) / (test)


if __name__ == "__main__":

    res = int(main(4, 44,2,2,3,4,5,6,1,-10,22))

    print(f"result={res}")

```
### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/lab_4/4.jpg)
 
## Выводы

В данном коде мы изучили приципа работы `args` принцип похож на массив у нас есть множество чисел с которыми мы можем работать просто указывая индекс числа либо можем сложит ьвсе числа входящии в `args` 

## Лабораторная работа №5

### Напишите функцию, которая на вход получает кортеж "**kwargs" и при помощи цикла выводит значения, поступившие в функцию. На скриншоте ниже указаны два варианта вызова функции с ***kwargs" и два варианта работы с данными, поступившими в эту функцию. Комментарии в коде и теоретическая часть помогут вам разобраться в этом нелегком аспекте. Вызовите функцию используя "точку входа".

```python
def main (**kwargs):
    for i in kwargs.items():
        print(i[0], i[1])

    print()

    for key in kwargs:
        print(f"{key} = {kwargs[key]}")


if __name__ == "__main__":
    main(x = [1,2,3], y=[44,4,0], z=[4,44,444,4444])
    print()
    main(**{"x": [4,44,444]})

```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/lab_4/5.jpg)

## Выводы

В данном коде мы познакомились с словарём `kwargs` суть его в том что бы хранить в себя такие элементы как ключ - значение, я пока с трудом представляю как можно это применить. но думаю дело практики чем больше буде делать тем быстрее найду применение данному аргументу. отличия между `main(**{"x": [4,44,444]})` и `main(x = [1,2,3], y=[44,4,0], z=[4,44,444,4444])
` в способе передачи данных. `main(**{"x": [4,44,444]})` - использует оператор развертывания словаря для передачи аргументов в виде словаря, где ключами служат имена аргументов, а значениями — соответствующие значения.

## Лабораторная работа №6


### Напишите две функции. Первая - получает в виде параметра
***kwargs". Вторая считает среднее арифметическое из значений первой функции. Вызовите первую функцию используя "точку вххода" и минимум 4 аргумента.

```python
def main(**kwargs):

    for i, j in kwargs.items():
        print(f"{i}. среднее арифметическое = {mean(j)}")


def mean(da):

    return sum(da) / float(len(da))


if __name__ == "__main__":

    main(x=[4,44,444], y = [4,44,44,444,44,44,4])
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/lab_4/6.jpg)

## Выводы

В данном коде мы высчитываем среднее арифметическое каждого ключа, x = ключ, [4,44,444] = значение. знения мы получаем из функции `main` и уже в функции `mean` находим среднее арифметическо через длинну и сумму чисел.

## Лабораторная работа №7

### 

```python
from lab import say

if __name__ == "__main__":
    say()

```

```python
def say():
    print("what?")
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/lab_4/7.jpg)

## Выводы

В данном коде мы вызываем функцию из другого файла, важно что бы файл находился в одной директории а также не содержал точек с числами иначе программа распознёт 

## Лабораторная работа №8

### 

```python
from math import *


def main():
    val = int(input("введите число: "))
    print(sqrt(val))
    print(sin(val))
    print(cos(val))


if __name__ == "__main__":
    main()
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/lab_4/8.jpg)

## Выводы

в данном задании мы рассмотрели 3 размличных способа импорта оператора `math` как по мне самый удобный через `*` такак дальнейший синтаксис становится проще и удобней, и не нужно указывать отдельно каждую функцию.

## Лабораторная работа №9

### Напишите программу, которая будет рассчитывать какой день недели будет через n-нное количество дней, которые укажет пользователь.

```python
from datetime import datetime as dt
from datetime import timedelta as td


def week(weekday):
    weekdays = {1: "Понедельник",
               2: "Вторник",
               3: "Среда",
               4: "Четверг",
               5: "Пятница",
               6: "Суббота",
               7: "Воскресенье",
    }
    return weekdays.get(weekday)


def dat():
    print(
        f"сегодня{dt.today().date()}.\n"
        f"день недели - {week(dt.today().isoweekday())}"
    )
    n = int(input("введите количество дней"))
    today = dt.today()
    res = today + td(days=n)
    print(
        f"через {n} дней будет {res.date()}\n"
        f"день недели - {week(res.isoweekday())}"
    )


dat()
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/lab_4/9.jpg)

## Выводы

В данном коде мы узнали что мочжно создавать псевданимы для операторов. так же изучили небольшую часть работы с датами, `datetime` данный оператор позволяет работать со временем, а `timedelta` этот оператор позволяет выполнять математические дествия со временем. в данную программу я посчитал нужным добавить названия дней недели так привычнее глазу для этого я создал функцию которая каждому номеру дня присваит значение ввиде слова, а именно дня недели. Выяснил интересное различие между `today` и `now` суть в том что при помощи `now` можно выбирать разные временные зоны, но если ничег оне указывать то он выдаст ту что у вас на компьютере. по сути в этой задаче мы так же могли применить `now` 

## Лабораторная работа №10

### Напишите программу с использованием глобальных переменных, которая будет считать площадь треугольника или прямоугольника в зависимости от того, что выберет пользователь. Получение всей необходимой информации реализовать через input(), а подсчет площадей выполнить при помощи функций. Результатом программы будет число, равное площади, необходимой фигуры.


```python
global result


def prim():
    a = int(input("Ширина "))
    b = int(input("Высота "))
    global result
    result = a * b


def tria():
    a = int(input("Длинна основания"))
    h = int(input("Высота"))
    global result
    result = (a*h)/2


fi = input("1 - прямоугольник, 2 - треугольник: ")

if fi == "1":
    prim()
elif fi == "2":
    tria()

print(f"Площадь фигуры: {result}")
```

### Результат 1.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/lab_4/10.1.jpg)

### Результат 2.
 
![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/lab_4/10.2.jpg)


## Вывод

В данной лабараторной мы рассмотрели как работают глобальные переменные, мы увидели что при помощи глобальной переменной можно выводить ответ в зависимости от то го какая функция выбрана пользователем, так же это упрощает код ведь не нужно для каждой функции по отдельности прописывать переменную для вывода на экран.

## Самостоятельная работа №1

### Дайте подробный комментарий для кода, написанного ниже. Комментарий нужен для каждой строчки кода, нужно описать что она делает. Не забудьте, что функции комментируются по-особенному.

```peyhon
from datetime import datetime  # Импорт модуля datetime для работы со временем
from math import sqrt  # Импорт функции sqrt из модуля math для вычисления квадратного корня

def main(**kwargs):  # Определение функции main с переменным числом именованных аргументов

    for key in kwargs.items():  # Итерация по парам ключ-значение из переданных аргументов
        result = sqrt(key[1][0] ** 2 + key[1][1] ** 2)  # Вычисление значения с использованием квадратного корня и арифметических операций
        print(result)  # Вывод значения результата

if __name__ == "__main__":  # Условие, которое проверяет, является ли данный модуль точкой входа программы

    start_time = datetime.now()  # Запись текущего времени в переменную start_time

    main(  # Вызов функции main с передачей именованных аргументов
        one=[10, 3],
        two=[5, 4],
        three=[15, 13],
        four=[93, 53],
        five=[133, 15]
    )

    time_costs = datetime.now() - start_time  # Вычисление разницы между текущим временем и start_time
    print(f"Время выполнения программы - {time_costs}")  # Вывод времени выполнения программы
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/tema_4/1.jpg)

## Вывод
 
Данная программа считает значения которые берёт из библиотеки 
`kwargs`. `result = sqrt(key[1][0] ** 2 + key[1][1] ** 2)` gj не сразу понял как работает но сейчас понимаю, и так [1]- ключ в нашем случае `one`[0] это индекс символа который присвоен в ключе `one` [1][1] а тут уже второй символ и благодаря циклу `for` программа прогоняется по всем ключам по очереди. 

## Самостоятельная работа №2


###  Напишите программу, которая будет заменять игральную кость с 6 гранями. Если значение равно 5 или 6, то в консоль выводится «Вы победили», если значения 3 или 4, то вы рекурсивно должны вызвать эту же функцию, если значение 1 или 2, то в консоль выводится «Вы проиграли». При этом каждый вызов функции необходимо выводить в консоль значение "кубика". Для выполнения задания необходимо использовать стандартную библиотеку random. Программу нужно написать, используя одну функцию и "точку входа"


```python
import random


def roll_dice():

    kub = random.randint(1, 6)
    print("На кубике выпало", kub)

    if kub == 5 or kub == 6:
        print("Вы победили")
    elif kub == 3 or kub == 4:
        print("Ничего не произошло. Бросаем кубик снова...")
        roll_dice()
    else:
        print("Вы проиграли")


if __name__ == "__main__":
    roll_dice()
```


### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/tema_4/2.1.jpg)

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/tema_4/2.2.jpg)

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/tema_4/2.3.jpg)


## Вывод

В данной программе мы при помощи цикла `if` делаем проверку что значение находится в диапазоне от 6 до 5, затем если это условие не выполняется идёт следующее условие проверка диапазона от 3 до 4 тогда выводим `ничего не произошло. бросаем кубик снова` затем рекурсивно вызываем эту же функции, честно довольно на долго подвис с рекурсией. из за того что не понял формулировку и пытался при вызове рекурси выводить результа `выпобедили`.


## Самостоятельная работа №3

### Напишите программу, которая будет выводить текущее время, с точностью до секунд на протяжении 5 секунд. Программу нужно написать с использованием цикла. Подсказка: необходимо использовать модуль datetime и time, а также вам необходимо как-то "усыплять" программу на 1 секунду.

```python
import datetime as dt
import time

for i in range(5):
    i = dt.datetime.now()
    print(i.strftime("%H:%M:%S"))
    time.sleep(1)
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/tema_4/3.jpg)

## Вывод

В данной программе мы вывели время в течении 5 сек с интервалом в одну секунду интервал достигается за счёт усыпления на 1 сек. использовали цикл `for`. 

## Самостоятельная работа №4

### Напишите программу, которая считает среднее арифметическое от аргументов вызываемое функции, с условием того, что изначальное количество этих аргументов неизвестно. Программу необходимо реализовать используя одну функцию и "точку входа".

```python
def process_values(*args):
    i = len(args)

    ss = sum(args)

    print("среднее арифметическое: ", int(ss/i))


user_values = input("Введите значения через пробел: ").split()

user_values = [int(val) for val in user_values]

process_values(*user_values)

```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/тема_3/tema_3/4.jpg)

## Вывод

В данном коде я реализовал получение чисел. `*args` принимает значения которые передаются нам от пльзователь через `input` за тем `split` разделяет эти числа что бы они не были одни большим числом по умолчанию разделить пробел но его можно указать и в скобках. в строке `11` мы преобразуем формат из строковго в целочисленный. `*` мы используем для распаковки списка и передачи его как аргументов.

## Самостоятельная работа №5

### Создайте два Python файла, в одном будет выполняться вычисление площади треугольника при помощи формулы Герона (необходимо реализовать через функцию), а во втором будет происходить взаимодействие с пользователем (получение всей необходимой информации и вывод результатов). Напишите эту программу и выведите в консоль полученную площадь.


### файл geron.py

```python
import math

def geron(a,b,c):

    s = (a+b+c/2)
    plo = math.sqrt(s * (s - a) * (s - b) * (s - c))
    return plo
```

### файл user.py 

```python
from geron import geron


def user():
    a = float(input("введите длинну стороны a: "))
    b = float(input("введите длинну стороны b: "))
    c = float(input("введите длинну стороны c: "))
    return a, b, c

a, b, c = user()

tria = geron(a, b, c)

print("Площадь ровна: ", tria)

```


### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_4/tema_4/5.jpg)

## Вывод

В донной работе мы сделали 2 файла один принимает даныые от пользователя а другой получает эти данные и считает их псоле вычислений их результат мы отправляем обратно в первый файл в котором уже происходит вывод ответа.

## общий Вывод по теме

В данной теме мы рассмотрели функции и модули, научили вызывать функции в разных файлах так же научились создавать глобальные переменные, Так же научились использовать кортежи такие как `args` и `kwargs`  основная их разница в том что один принимает просто список значений а втрой принимает ключ значение. научились инмпортировать функции(скрипты) это может быть очень полезно при работе с большими проектами где нужно писать много кода и что бы не засорять код можно писать отдельно небольшие скрипты. посмотрели как импортировать модули встроеные в python, узнали разницу между полным импортом всех свойств и частичным. посмотрели как можно работать со временем, узнали как присвоить модулю другое название для упрощения его написания в коде. 