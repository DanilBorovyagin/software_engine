# Тема 9. Концепции и принципы ООП
Отчет по Теме #9 выполнил:
- Боровягин Данил Андреевич
- ПИЭ-21-2

| Задание | Сам_раб |
| ------ | ------ |
| Задание 1 | + |

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1

### Задания для самостоятельного выполнения:
Задание Садовник и помидоры.
Классовая структура:
	Есть Помидор со следующими характеристиками:
		Индекс
		• Стадия созревания (стадии: отсутствует, цветение, зеленый, 			красный)
	Помидор может:
		•Расти (переходить на следующую стадию созревания)
		Предоставлять информацию о своей зрелости

	Есть Куст с помидорами, который:
		Содержит список томатов, которые на нем растут
	А также может:
		•Расти вместе с томатами
		Предоставлять информацию о зрелости всех томатов
		Предоставлять урожай
	также есть Садовник, который имеет:
		Имя
		• Растение, за которым он ухаживает
	Он может:
		Ухаживать за растением
		Собирать с него урожай

```python
class Tomato:
    states = ["отсутствует", "цветение", "зеленый", "красный"]  # создаём список стадий созревания томатов

    def __init__(self, index):
        self._index = index  # защищённый атрибут
        self._state = self.states[0]  # защищённый атрибут

    def grow(self):
        current = self.states.index(self._state)  # присваиваем индекс текущей стадии переменной
        if current < len(self.states) - 1:  # проверяем что бы список не кончился
            self._state = self.states[current + 1]  # присваиваем значение из списка + 1

    def is_ripe(self):
        if self._state == self.states[3]:  # проверяем созрел ли томат, путём присвоения индекса ‘красный’ = созрел
            return True  # возвращаем True
        else:
            return False  # возвращаем False


class TomatoBush:

    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato(index) for index in range(num_tomatoes)]  # создаём список экземпляров класса Tomato
        self.grow_print()  # выводим список

    def grow_all(self):
        for tomato in self.tomatoes:  # проводит итерации по всему списку благодаря чему каждый элемента списка преходит на следующую стадию созревания
            tomato.grow()  # проводит операцию grow
        self.grow_print()  # выводит обнавлённый список

    def grow_print(self):  # метод для вывода списка в консоль
        for tomato in self.tomatoes:  # преобразуем в список
            print(tomato._state)  # выводит список состояния помидоров

    def all_are_ripe(self):
        for tomato in self.tomatoes:  # проводит итерации по всему списку проверяя на зрелость каждый элемент списка
            if not tomato.is_ripe():  # выполняем проверку задействую метод из класса Tomato
                return False # возвращаем False
        return True  # возвращаем True

    def give_away_all(self):
        if self.all_are_ripe():  # проверяем спелость томатов с помощью метода all_are_ripe
            print("сбор урожая...")  # выводит надпись
            self.tomatoes = []  # создаём пустой список
            print("урожай собран")  # выводит надпись
        else:
            print("томаты не созрели")    # выводит надпись


class Gardener:
    def __init__(self, name, plant):
        self.name = name  # публичный атрибут
        self._plant = plant  # защищённый атрибут

    def work(self):
        self._plant.grow_all()  # для ухаживания за кустом просто обращаемся к методу который перводит все томаты на новый этам созревания grow_all

    def harvest(self):
        if self._plant.all_are_ripe():  # проверяем спелость томатов с помощью метода all_are_ripe
            print("сбор урожая...")  # выводит надпись
            self._plant.give_away_all()  # собираем урожай при помощи метода give_away_all и оставляем пустой список
            print("урожай собран")  # выводит надпись
        else:
            print("ещё рано для сбора не все томаты созрели")  # выводит надпись

    @staticmethod  # объявление статического метода
    def knowledge_base():  # выводит справку
        print("Справка по садоводству:")  # выводит надпись
        print("- Поддерживайте растения в хорошем состоянии, поливайте их и удаляйте сорняки.")  # выводит надпись
        print("- Регулярно проверяйте состояние растений и собирайте урожай, когда плоды созреют.")  # выводит надпись


Gardener.knowledge_base()
gardener = Gardener("джон", TomatoBush(3))
gardener.work()
gardener.harvest()
gardener.work()
gardener.work()
gardener.harvest()

```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_9/tema_9/1.jpg)

## листинг

Этот код моделирует работу садовода, который ухаживает за кустом томатов. Класс `Tomato` представляет отдельный томат на кусте и имеет атрибуты `_index` (защищённый атрибут, содержащий индекс томата) и `_state` (защищённый атрибут, содержащий текущую стадию созревания томата). Класс `TomatoBush` представляет собой куст томатов и содержит список томатов (`tomatoes`). Метод `grow_all` переводит все томаты на следующую стадию созревания, метод `grow_print` выводит состояние каждого томата, метод `all_are_ripe` проверяет, все ли томаты созрели, а метод `give_away_all` собирает урожай, если все томаты созрели.

Класс `Gardener` представляет садовода и имеет атрибуты `name` (публичный атрибут, содержащий имя садовода) и `_plant` (защищённый атрибут, содержащий объект `TomatoBush`). Метод `work` вызывает метод `grow_all` для ухода за кустом томатов, а метод `harvest` проверяет, все ли томаты созрели, и если да, собирает урожай.

Наконец, статический метод `knowledge_base` класса `Gardener` выводит справку по садоводству.

В приведенном примере кода сначала вызывается статический метод `knowledge_base`, который выводит справку по садоводству. Затем создается экземпляр `gardener` класса `Gardener` с именем "Джон" и кустом томатов на 3 растения. Вызывается метод `work`, чтобы ухаживать за кустом томатов (переводить их на следующую стадию созревания), затем вызывается метод `harvest`, чтобы собрать урожай, если все томаты созрели. После этого вызывается метод `work` еще два раза, а затем снова вызывается метод `harvest`.

## Вывод

В данном коде мы поработали сразу с несколькими классами и увидели, как они могут взаимодействовать. Мы не применили приватные атрибуты так как все классы в нашем случае взаимосвязаны, но при желании мы могли сделать приватный атрибут и образуется к нему через метод. На данную работу при хорошем понимании ушло не так уж много времени буквально час или чуть больше. 

## общий Вывод по теме

В заключении проделанной работы могу сказать, что написание подобных программ очень интересно и полезно для понимания взаимосвязей между классами. Так же что не мало важно в данной теме мы изучили сеттер, геттер и деструктор это виду доступа к приватным классам (используются чаще всего). Так же нашли применение для статистического метода. 
