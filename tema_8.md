# Тема 8. введение в ООП
Отчет по Теме #8 выполнил:
- Боровягин Данил Андреевич
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1

### Создайте класс "Car" с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями.

```python
class Mobil:  # создаём класс Mobil
    def __init__(self, make, model):  # создаём функцию, инициализируем новый объект
        self.make = make  # обращение к атрибуту make
        self.model = model  # обращение к атрибуту model

    def __str__(self):  # определяет строкове значение в классе Mobil
        # возвращает строку соджащую строкове значение атрибутов make и model
        return f"производитель = {self.make}, модель = {self.model}"


my_mobil = Mobil("Samsung", "s10e")
print(my_mobil)

```


### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_8/lab_8/1.jpg)

## листинг

Этот код определяет класс `Mobil` с конструктором `__init__`, который инициализирует атрибуты `make` и `model` объекта. Метод `__str__` переопределен для возвращения строкового представления объекта `Mobil, содержащего значения атрибутов `make` и `model`.

Затем создается объект `my_mobil` класса `Mobil` с аргументами `"Samsung"` и `"s10e"`. И наконец, метод `print()` используется для вывода строки, возвращаемой методом `__str__`, на экран.

## Выводы

В данном коде мы создали класс `Mobil` интересный факт имя класса обязательно с заглавной буквы, затем инициализировали новый объект при помощи `__init__` задали ему 2 атрибута `make`, `model` ещё я добавил возможность вывести это на экран по средством функции `__str__` которая возвращает нам текст. 

## Лабораторная работа №2

### Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину "поехать". Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Mobil:  # создаём класс Mobil
    def __init__(self, make, model):  # создаём функцию, инициализируем новый объект
        self.make = make  # обращение к атрибуту make
        self.model = model  # обращение к атрибуту model

    def us(self):  # создаём функцию для вывода значений атрибутов на экран 
        print(f"use my smartphone company {self.make} models {self.model}")  # выводим значения на экран


my_mobil = Mobil("samsung", "S10")  # задаём значения для атрибутов
my_mobil.us()  # вызываем функцию us для вывода в консоль
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_8/lab_8/2.jpg)

## Листинг

Этот код определяет класс `Mobil` с конструктором `__init__`, который инициализирует атрибуты `make` и `model` объекта. Затем определен метод `us`, который выводит значения атрибутов `make` и `model` на экран с помощью функции `print`.

Далее создается объект `my_mobil` класса `Mobil` с аргументами `"samsung"` и `"S10"`. И вызывается метод `us()` для этого объекта

## Лабораторная работа №3

### Создайте новый класс "ElectricCar" с методом "charge" и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Mobil:  # создаём класс Mobil
    def __init__(self, make, model):  # создаём функцию, инициализируем атрибуты(парметры)
        self.make = make  # обращение к атрибуту make
        self.model = model  # обращение к атрибуту model

    def us(self):  # создаём функцию для вывода значений атрибутов на экран
        print(f"use my smartphone company {self.make} models {self.model}")  # выводим значения на экран


my_mobil = Mobil("samsung", "S10")  # задаём значения для атрибутов
my_mobil.us()  # вызываем функцию us для вывода в консоль


class smartphone(Mobil):  # создание нового класса с указанием родительского
    def __init__(self, make, model, battery):  # создаём функцию, инициализируем атрибуты(параметры)
        super().__init__(make, model)  # вызывает конструктор родительского класса и передаёт ему значение аргументов
        self.battery = battery  # обращение к атрибуту battery

    def charge(self):  # создаём функцию для вывода значений атрибутов на экран
        print(f"Charging the {self.make} {self.model} with {self.battery} kWh")  # выводим значения на экран


my_smartphone = smartphone("Samsung", "S10e", 75)  # задаём значения для атрибутов
my_smartphone.us()  # вызываем функцию us для вывода в консоль
my_smartphone.charge()  # вызываем функцию charge для вывода в консоль
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_8/lab_8/3.jpg)

## Листинг

Этот код создает два класса: `Mobil` и `smartphone`. Класс `Mobil` имеет атрибуты `make` и `model`, и метод `us`, который выводит информацию о производителе и модели смартфона.

Класс `smartphone` наследует от класса `Mobil` и добавляет дополнительный атрибут `battery`. Он также имеет метод `charge`, который выводит информацию о зарядке смартфона, включая производителя, модель и емкость батареи.

В основной части кода создается объект `my_mobil` класса `Mobil` с аргументами `"samsung"` и `"S10"`. Затем вызывается метод `us`, который выводит информацию о производителе и модели.

Затем создается объект `my_smartphone` класса `smartphone` с аргументами `"Samsung"`, `"S10e"` и `75`. Затем вызываются методы `us` и `charge`, которые выводят информацию о производителе, модели и зарядке смартфона.

## Лабораторная работа №4

### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Mobil:  # создаём класс Mobil
    def __init__(self, make, model):  # создаём функцию, инициализируем новый объект
        self._make = make  # обращение к защищённому атрибуту make
        self.__model = model  # обращение к приваиному атрибуту model

    def __str__(self):  # определяет строкове значение в классе Mobil
        # возвращает строку соджащую строкове значение атрибутов make и model
        return f"производитель = {self._make}, модель = {self.__model}"

    def us(self):  # создаём функцию для вывода значений атрибутов на экран
        print(f"use my smartphone company {self._make} models {self.__model}")  # выводим значения на экран


my_mobil = Mobil("Samsung", "S10e")
print(my_mobil._make)  # доступ к защищёному атрибуту
my_mobil.us()  # вызов метода
```
### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_8/lab_8/4.jpg)
 
## Листинг 

В этом коде класс `Mobil` содержит следующие элементы:

Конструктор `__init__`, который принимает аргументы `make` и `model` и инициализирует атрибуты `self._make` и `self.__model` соответствующими значениями.

Метод `__str__`, который возвращает строковое представление объекта класса `Mobil`. В данном случае, он форматирует и возвращает строку, содержащую значения атрибутов `self._make` и `self.__model`.

Метод `us`, который выводит на экран сообщение, используя значения атрибутов `self._make` и `self.__model`.

Создание объекта `my_mobil` класса `Mobil` с аргументами `"Samsung"` и `"s10e"`.

Вывод значения защищенного атрибута `my_mobil._make` с использованием синтаксиса доступа к атрибутам через точку.

Вызов метода `my_mobil.us()`, который выводит сообщение, используя значения атрибутов.

## Лабораторная работа №5

### Реализуйте полиморфизм создав основной (общий) класс "Shape", а также еще два класса "Rectangle" и "Circle". Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Shape:  # создаём родительский класс
    def area(self):  # пустой метод area
        pass


class Kva(Shape):  # создаём наследственный класс
    def __init__(self, a, b):  # инициализируем атрибуты
        self.a = a  # обращение к атрибуту
        self.b = b  # обращение к атрибуту

    def area(self):  # инициализируем метод
        return self.a * self.b  # Возвращаем площадь прямоугольника


class Cir(Shape):  # создаём наследственный класс
    def __init__(self, r):  # инициализируем атрибуты
        self.r = r  # обращение к атрибуту

    def area(self):  # инициализируем метод
        return 3.14 * self.r * self.r  # Возвращаем площадь круга


shapes = [Kva(5, 5), Cir(3)]  # Создаем список объектов разных фигур
for Shape in shapes:
    print(Shape.area())  # Выводим площадь каждой фигуры  
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_8/lab_8/5.jpg)

## Листинг

Это код, который определяет родительский класс `Shape`, а затем два наследующих его класса `Kva` и `Cir`. В каждом классе определен метод `area()`, который возвращает площадь соответствующей фигуры (прямоугольника или круга). Затем создается список `shapes`, содержащий экземпляры этих классов. В цикле `for` проходим по каждому элементу списка и вызываем метод `area()` для каждой фигуры, выводя результат в консоль.

## Вывод

Как я понял полиморфизм помогает упростить вывод так как не рпидётся прописывать всё отдельно, а можно через цикл `for` обратится ко всем объектам так же можно и к конкретному обратится, возможно я ошибаюсь так как полиморфизм вроде понял как работает, но с трудом представляю где и как его стоит преминять.

## Самостоятельная работа №1

### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
rol = input("введите роль: ")
drawing = input("ближний бой или дальний бой ")
champions = input("Введите чампиона: ")


class Lol:
    def __init__(self, role, draw, champ):
        self.role = role
        self.draw = draw
        self.champ = champ

    def play(self):
        print(f"ваша роль {self.role} ваш чампион {self.champ} дальность атаки вашего чампиона {self.draw}")


my_lol = Lol(rol, drawing, champions)
my_lol.play()
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_8/tema_8/1.jpg)

## листинг

В этом коде пользователю предлагается ввести роль `rol`, тип атаки (ближний бой или дальний бой - `drawing`) и имя чемпиона `champions`. Затем определяется класс Lol с конструктором `__init__`, который инициализирует атрибуты `role`, `draw` и `champ` для объекта класса. Метод `play` выводит значения атрибутов на экран с помощью функции `print`.

Далее создается объект `my_lol` класса `Lol` с аргументами, введенными пользователем. Метод `play` вызывается для этого объекта, что приводит к выводу информации о роли, чемпионе и дальности атаки на экран.

## Самостоятельная работа №2

###  Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
rol = input("введите роль: ")
drawing = input("ближний бой или дальний бой ")
champions = input("Введите чампиона: ")


class Lol:
    def __init__(self, role, draw, champ):
        self.role = role
        self.draw = draw
        self.champ = champ

    def play(self):
        print(f"ваша роль:{self.role} ваш чампион:{self.champ} дальность атаки вашего чампиона:{self.draw}")

    def get_info(self):
        print(f"роль: {self.role}\nчемпион: {self.champ}\nдальность атаки: {self.draw}")

    def is_mage(self):
        mages = ["аурелион сол", "вейгар", "зиггс"]
        if self.champ in mages:
            return print("чемпион является магом")
        else:
            return print("чампион не является магом")


my_lol = Lol(rol, drawing, champions)
my_lol.play()
my_lol.get_info()
my_lol.is_mage()
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_8/tema_8/2.jpg)

## листинг

Этот код позволяет пользователю вводить роль, дальность атаки и чемпиона, а затем создает экземпляр класса `Lol` с введенными значениями. После этого вызываются методы `play`, `get_info` и `is_mage` для вывода информации о роли, чемпионе, дальности атаки и проверки, является ли чемпион магом.

## Самостоятельная работа №3

### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
rol = input("введите роль: ")
drawing = input("ближний бой или дальний бой ")
champions = input("Введите чампиона: ")


class Lol:
    def __init__(self, role, draw, champ):
        self.role = role
        self.draw = draw
        self.champ = champ

    def play(self):
        print(f"ваша роль:{self.role} ваш чампион:{self.champ} дальность атаки вашего чампиона:{self.draw}")

    def get_info(self):
        print(f"роль: {self.role}\nчемпион: {self.champ}\nдальность атаки: {self.draw}")

    def is_mage(self):
        mages = ["аурелион сол", "вейгар", "зиггс"]
        if self.champ in mages:
            return print("чемпион является магом")
        else:
            return print("чампион не является магом")


my_lol = Lol(rol, drawing, champions)
my_lol.play()
my_lol.is_mage()


class ATK(Lol):
    def __init__(self, role, draw, champ, ad, ap):
        super().__init__(role, draw, champ)
        self.ad = ad
        self.ap = ap

    def TXT_ATK(self):
        print(f"роль: {self.role}\nчемпион: {self.champ}\nдальность атаки: {self.draw}\nад урон: {self.ad}\nап урон: {self.ap}")

    def is_ATK(self):
        ap_champ = ["аурелион сол", "вейгар", "зиггс"]
        if self.champ in ap_champ:
            return print(f"урон ап {self.ap}")
        else:
            return print(f"урон ад {self.ad}")


my_ATK = ATK(rol, drawing, champions, 130, 240)
my_ATK.TXT_ATK()
my_ATK.is_ATK()
```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_8/tema_8/3.jpg)

## Листинг

Сначала у нас есть три строки кода, которые запрашивают у пользователя ввод роли `(rol)`, типа атаки `(drawing)` и имени чемпиона `(champions)`.

Затем определен класс `Lol`, который является базовым классом для представления персонажа в игре `League of Legends`. Он имеет конструктор `__init__`, который инициализирует атрибуты `role`, `draw` и `champ` на основе переданных аргументов.

В классе `Lol` есть метод `play`, который выводит информацию о роли, чемпионе и дальности атаки чемпиона.

Также в классе `Lol` есть метод `get_info`, который выводит подробную информацию о роли, чемпионе и дальности атаки чемпиона.

Класс `Lol` также имеет метод `is_mage`, который проверяет, является ли чемпион магом. В данном случае, список магов содержит имена "аурелион сол", "вейгар" и "зиггс". Если имя чемпиона находится в списке магов, выводится сообщение "чемпион является магом", в противном случае выводится сообщение "чемпион не является магом".

Затем создается экземпляр класса `Lol` с переданными значениями `rol, drawing и champions`. Мы вызываем методы `play` и `is_mage` для этого экземпляра, чтобы вывести информацию о роли, чемпионе, дальности атаки и проверить, является ли чемпион магом.

Далее определен класс `ATK`, который наследуется от класса `Lol`. Этот класс представляет персонажа с атакой и имеет дополнительные атрибуты `ad` (физический урон) и `ap` (магический урон).

Класс `ATK` имеет свой конструктор `__init__`, который вызывает конструктор базового класса и инициализирует атрибуты `ad` и `ap` на основе переданных аргументов.

В классе `ATK` есть метод `TXT_ATK`, который выводит подробную информацию о роли, чемпионе, дальности атаки, физическом уроне и магическом уроне.

Также в классе `ATK` определен метод `is_ATK`, который проверяет, является ли чемпион атакующим персонажем. В данном случае, список чемпионов с магическим уроном содержит имена "аурелион сол", "вейгар" и "зиггс". Если имя чемпиона находится в списке, выводится сообщение "урон ап" с указанием магического урона, в противном случае выводится сообщение "урон ад" с указанием физического урона.

Затем создается экземпляр класса `ATK` с переданными значениями `rol, drawing, champions, 130 и 240` для атрибутов `ad` и `ap` соответственно. Мы вызываем методы `TXT_ATK` и `is_ATK` для этого экземпляра, чтобы вывести информацию о роли, чемпионе, дальности атаки и типе урона.

## Самостоятельная работа №4

### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
rol = input("введите роль: ")
drawing = input("ближний бой или дальний бой ")
champions = input("Введите чампиона: ")


class Lol:
    def __init__(self, role, draw, champ):
        self._role = role
        self.draw = draw
        self.__champ = champ

    def play(self):
        print(f"ваша роль:{self._role} ваш чампион:{self.__champ} дальность атаки вашего чампиона:{self.draw}")

    def get_info(self):
        print(f"роль: {self._role}\nчемпион: {self.__champ}\nдальность атаки: {self.draw}")

    def is_mage(self):
        mages = ["аурелион сол", "вейгар", "зиггс"]
        if self.__champ in mages:
            return print("чемпион является магом")
        else:
            return print("чампион не является магом")

    def access(self):
        return self.__champ


my_lol = Lol(rol, drawing, champions)
my_lol.play()
my_lol.is_mage()


class ATK(Lol):

    def __init__(self, role, draw, champ, ad, ap):
        super().__init__(role, draw, champ)
        self.ad = ad
        self.ap = ap

    def TXT_ATK(self):
        print(f"роль: {self._role}\nчемпион: {self.access()}\nдальность атаки:"
              f"{self.draw}\nад урон: {self.ad}\nап урон: {self.ap}")

    def is_ATK(self):
        ap_champ = ["аурелион сол", "вейгар", "зиггс"]
        if self.access() in ap_champ:
            return print(f"урон ап {self.ap}")
        else:
            return print(f"урон ад {self.ad}")


my_ATK = ATK(rol, drawing, champions, 130, 240)
my_ATK.TXT_ATK()
my_ATK.is_ATK()

```

### Результат(скриншот 1).

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_8/tema_8/4.1.jpg)

### Результат(скриншот 2).

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_8/tema_8/4.2.jpg)

## Листинг

Создание класса `Lol`:

Создание метода `__init__`, который инициализирует атрибуты `role`, `draw` и `champ`.

Создание метода `play`, который выводит информацию о роли, чемпионе и типе атаки.

Создание метода `get_info`, который выводит информацию о чемпионе.

Создание метода `is_mage`, который проверяет, является ли чемпион магом.

Создание метода `access`, который возвращает приватный атрибут `champ`.

Создание объекта `my_lol` класса `Lol` с введенными значениями роли, типа атаки и чемпиона.

Вызов метода `play` для вывода информации о роли, чемпионе и типе атаки.

Вызов метода `is_mage` для проверки, является ли чемпион магом.

Создание класса `ATK`, наследующегося от класса `Lol`:

Создание метода `__init__`, который вызывает конструктор родительского класса и инициализирует атрибуты `ad` и `ap`.

Создание метода `TXT_ATK`, который выводит информацию о роли, чемпионе, типе атаки и уроне атаки.

Создание метода `is_ATK`, который проверяет тип урона чемпиона (физический или магический).

Создание объекта `my_ATK` класса `ATK` с введенными значениями роли, типа атаки, чемпиона, физического и магического урона.

Вызов метода `TXT_ATK` для вывода информации о роли, чемпионе, типе атаки и уроне атаки.

Вызов метода `is_ATK` для проверки типа урона чемпиона (физический или магический).

В коде используются конструкции ввода данных с помощью функции `input()` и вывода информации с помощью функции `print()`.

## Вывод

В данном коде я продемонстрировал как работает инкапсуляция. защищёный атрибут _, приватный атрибут __, разница лишь в том что первый вариант это негласное правило между програмистами указывающее на то что с этим атрибутом нужно быть осторожней, а второй вариант полностью блокирует атрибут для доступа к нему из вне (скриншо 1). Но можно создать мотод через который будем получать доступ к этому атрибуту из внешних источников (скриншот 2)

## Самостоятельная работа №5

### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Animal:
    def sound(self):
        pass


class Cat(Animal):
    def sound(self):
        return "мяу"


class Dog(Animal):
    def sound(self):
        return "гав"


class Cow(Animal):
    def sound(self):
        return "му"


class Pig(Animal):
    def sound(self):
        return "хрю"


animals = [Cat(), Dog(), Cow(), Pig()]
for Animal in animals:
    print(Animal.sound())

```

### Результат.

![Меню](https://github.com/DanilBorovyagin/software_engine/blob/Тема_8/tema_8/5.jpg)

## Листинг

Этот код определяет базовый класс `Animal` и его подклассы `Cat`, `Dog`, `Cow` и `Pig`. У каждого подкласса есть переопределенный метод `sound()`, который возвращает звук, характерный для соответствующего животного.

Затем создается список `animals`, содержащий экземпляры разных классов животных. В цикле `for` проходим по каждому элементу списка и вызываем метод `sound()` для каждого животного, выводя в консоль соответствующий звук.

## общий Вывод по теме

В данной теме мы рассмотрели первые шаги для вхожденияв ООП. Для начала мы научились создавать классы и обекты. Затем рассмотрели атрибуты и методы которые реализуются внутри классов, изучили что такое наследование и как оно работает, очень просто мы можем вызвать из родительского класса атрибуты котрые в нём уже определены, рассмотрели Инкапсуляцию это механиз мпозволяющий делать атрибуты как защищёными так и приватными при помощи `_` и `__` перед атрибутом. В конце поработали с полиморфизмом который позволяет объектам разных классов иметь общий интерфейс. В заключении важно отметить что данная тема это очень маленький шаг к огромному материалу связанному с ООП. 
